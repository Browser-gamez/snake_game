<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amazing Snake Game - WASD Edition</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: white;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .header {
            text-align: center;
            padding: 15px;
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 5px;
            background: linear-gradient(to right, #00b09b, #96c93d);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            font-size: 1.1rem;
            color: #a5d6ff;
            margin-bottom: 10px;
        }

        .game-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 10px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #4dffea;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #cccccc;
        }

        .game-board-container {
            position: relative;
            margin: 20px auto;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
        }

        #game-board {
            background-color: #111a22;
            display: block;
        }

        .controls-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            gap: 15px;
        }

        .controls-info {
            text-align: center;
            color: #a5d6ff;
            font-size: 1.1rem;
        }

        .keyboard-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .key {
            width: 70px;
            height: 70px;
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            font-weight: bold;
            box-shadow: 0 6px 0 #1a252f, 0 8px 10px rgba(0, 0, 0, 0.5);
            transition: all 0.1s;
            color: #ecf0f1;
        }

        .key.active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #1a252f, 0 4px 10px rgba(0, 0, 0, 0.5);
            background: linear-gradient(145deg, #3498db, #2980b9);
        }

        .key-w {
            grid-column: 2;
            grid-row: 1;
        }

        .key-a {
            grid-column: 1;
            grid-row: 2;
        }

        .key-s {
            grid-column: 2;
            grid-row: 2;
        }

        .key-d {
            grid-column: 3;
            grid-row: 2;
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            border-radius: 12px;
        }

        .game-over h2 {
            font-size: 3.5rem;
            color: #ff6b6b;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.7);
        }

        .final-score {
            font-size: 2.2rem;
            margin-bottom: 30px;
            color: #4dffea;
        }

        .btn {
            padding: 15px 35px;
            font-size: 1.2rem;
            background: linear-gradient(to right, #00b09b, #96c93d);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 6px 0 #008a72, 0 8px 15px rgba(0, 0, 0, 0.4);
            transition: all 0.2s;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 9px 0 #008a72, 0 11px 15px rgba(0, 0, 0, 0.4);
        }

        .btn:active {
            transform: translateY(3px);
            box-shadow: 0 3px 0 #008a72, 0 5px 15px rgba(0, 0, 0, 0.4);
        }

        .power-ups {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .power-up {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 10px;
            min-width: 120px;
        }

        .power-up i {
            font-size: 1.8rem;
            margin-bottom: 8px;
        }

        .speed-boost {
            color: #00ff9d;
        }

        .score-multiplier {
            color: #ffdd00;
        }

        .slow-time {
            color: #00b7ff;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .instructions h3 {
            color: #4dffea;
            margin-bottom: 8px;
        }

        .fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
        }

        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .snake-segment {
            position: absolute;
            border-radius: 4px;
            transition: all 0.1s;
        }

        .food {
            position: absolute;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .special-food {
            position: absolute;
            border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
            animation: rotate 4s infinite linear;
        }

        @keyframes rotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.2); }
            100% { transform: rotate(360deg) scale(1); }
        }

        @media (max-height: 850px) {
            .game-board-container {
                transform: scale(0.9);
            }
            
            .key {
                width: 60px;
                height: 60px;
                font-size: 1.5rem;
            }
        }

        @media (max-height: 700px) {
            .game-board-container {
                transform: scale(0.8);
            }
            
            .header {
                padding: 10px;
            }
            
            h1 {
                font-size: 2.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1><i class="fas fa-star"></i> AMAZING SNAKE GAME <i class="fas fa-star"></i></h1>
            <p class="subtitle">Use WASD keys to control the snake. Collect food, avoid walls and yourself!</p>
            <div class="game-stats">
                <div class="stat">
                    <div class="stat-value" id="score">0</div>
                    <div class="stat-label">SCORE</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="high-score">0</div>
                    <div class="stat-label">HIGH SCORE</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="length">1</div>
                    <div class="stat-label">LENGTH</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="speed">1x</div>
                    <div class="stat-label">SPEED</div>
                </div>
            </div>
        </div>

        <div class="game-board-container">
            <canvas id="game-board"></canvas>
            
            <div class="game-over" id="game-over">
                <h2>GAME OVER</h2>
                <div class="final-score">Your Score: <span id="final-score">0</span></div>
                <button class="btn" id="restart-btn"><i class="fas fa-redo"></i> PLAY AGAIN</button>
                <button class="btn" id="menu-btn" style="margin-top: 15px; background: linear-gradient(to right, #8e2de2, #4a00e0);">
                    <i class="fas fa-home"></i> BACK TO MENU
                </button>
            </div>
        </div>

        <div class="controls-container">
            <div class="controls-info">
                <p>Use <strong>W A S D</strong> keys to control the snake direction</p>
            </div>
            
            <div class="keyboard-controls">
                <div class="key key-w" id="key-w">W</div>
                <div class="key key-a" id="key-a">A</div>
                <div class="key key-s" id="key-s">S</div>
                <div class="key key-d" id="key-d">D</div>
            </div>
            
            <div class="power-ups">
                <div class="power-up">
                    <i class="fas fa-bolt speed-boost"></i>
                    <span>Speed Boost</span>
                    <small id="speed-timer">Inactive</small>
                </div>
                <div class="power-up">
                    <i class="fas fa-crown score-multiplier"></i>
                    <span>Score x2</span>
                    <small id="multiplier-timer">Inactive</small>
                </div>
                <div class="power-up">
                    <i class="fas fa-clock slow-time"></i>
                    <span>Slow Time</span>
                    <small id="slow-timer">Inactive</small>
                </div>
            </div>
        </div>

        <button class="fullscreen-btn" id="fullscreen-btn">
            <i class="fas fa-expand"></i>
        </button>

        <div class="instructions">
            <h3>How to Play:</h3>
            <p>• Use <strong>WASD</strong> keys to control the snake</p>
            <p>• Collect <span style="color:#ff6b6b">red food</span> for points</p>
            <p>• Collect <span style="color:#ffdd00">yellow food</span> for power-ups</p>
            <p>• Avoid hitting walls or yourself</p>
            <p>• The longer you get, the higher your score!</p>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('game-board');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score');
        const lengthElement = document.getElementById('length');
        const speedElement = document.getElementById('speed');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreElement = document.getElementById('final-score');
        const restartBtn = document.getElementById('restart-btn');
        const menuBtn = document.getElementById('menu-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        
        // Key elements for visual feedback
        const keyW = document.getElementById('key-w');
        const keyA = document.getElementById('key-a');
        const keyS = document.getElementById('key-s');
        const keyD = document.getElementById('key-d');
        
        // Power-up timer elements
        const speedTimer = document.getElementById('speed-timer');
        const multiplierTimer = document.getElementById('multiplier-timer');
        const slowTimer = document.getElementById('slow-timer');
        
        // Game settings
        const gridSize = 20;
        let gameSpeed = 120; // ms between updates
        let baseSpeed = 120;
        let speedMultiplier = 1;
        let scoreMultiplier = 1;
        
        // Game state
        let snake = [];
        let food = {};
        let specialFood = {};
        let direction = 'right';
        let nextDirection = 'right';
        let gameRunning = false;
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameLoop;
        
        // Power-up states
        let speedBoostActive = false;
        let scoreMultiplierActive = false;
        let slowTimeActive = false;
        let speedBoostEndTime = 0;
        let scoreMultiplierEndTime = 0;
        let slowTimeEndTime = 0;
        
        // Initialize game
        function init() {
            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Set high score
            highScoreElement.textContent = highScore;
            
            // Initialize snake
            snake = [
                {x: 10, y: 10},
                {x: 9, y: 10},
                {x: 8, y: 10}
            ];
            
            // Create first food
            createFood();
            createSpecialFood();
            
            // Set initial direction
            direction = 'right';
            nextDirection = 'right';
            
            // Reset score and speed
            score = 0;
            scoreElement.textContent = score;
            lengthElement.textContent = snake.length;
            speedElement.textContent = `${speedMultiplier}x`;
            
            // Hide game over screen
            gameOverScreen.style.display = 'none';
            gameRunning = true;
            
            // Start game loop
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, gameSpeed);
            
            // Update power-up timers
            updatePowerUpTimers();
        }
        
        // Resize canvas to fit screen
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth - 40, 800);
            canvas.width = size;
            canvas.height = size;
            
            // Redraw game if running
            if (gameRunning) {
                draw();
            }
        }
        
        // Create regular food
        function createFood() {
            const maxX = Math.floor(canvas.width / gridSize);
            const maxY = Math.floor(canvas.height / gridSize);
            
            food = {
                x: Math.floor(Math.random() * maxX),
                y: Math.floor(Math.random() * maxY)
            };
            
            // Make sure food doesn't appear on snake
            for (let segment of snake) {
                if (segment.x === food.x && segment.y === food.y) {
                    return createFood();
                }
            }
        }
        
        // Create special food (for power-ups)
        function createSpecialFood() {
            const maxX = Math.floor(canvas.width / gridSize);
            const maxY = Math.floor(canvas.height / gridSize);
            
            specialFood = {
                x: Math.floor(Math.random() * maxX),
                y: Math.floor(Math.random() * maxY),
                type: Math.floor(Math.random() * 3) // 0=speed, 1=multiplier, 2=slow
            };
            
            // Make sure special food doesn't appear on snake or regular food
            for (let segment of snake) {
                if (segment.x === specialFood.x && segment.y === specialFood.y) {
                    return createSpecialFood();
                }
            }
            
            if (food.x === specialFood.x && food.y === specialFood.y) {
                return createSpecialFood();
            }
        }
        
        // Update game state
        function update() {
            if (!gameRunning) return;
            
            // Update direction
            direction = nextDirection;
            
            // Calculate new head position
            const head = {...snake[0]};
            
            switch(direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }
            
            // Check wall collision
            const maxX = Math.floor(canvas.width / gridSize);
            const maxY = Math.floor(canvas.height / gridSize);
            
            if (head.x < 0 || head.x >= maxX || head.y < 0 || head.y >= maxY) {
                gameOver();
                return;
            }
            
            // Check self collision
            for (let segment of snake) {
                if (head.x === segment.x && head.y === segment.y) {
                    gameOver();
                    return;
                }
            }
            
            // Add new head to snake
            snake.unshift(head);
            
            // Check food collision
            if (head.x === food.x && head.y === food.y) {
                // Increase score
                score += 10 * scoreMultiplier;
                scoreElement.textContent = score;
                
                // Create new food
                createFood();
                
                // Update length
                lengthElement.textContent = snake.length;
                
                // Increase speed every 5 foods (but not too fast)
                if (score % 50 === 0 && gameSpeed > 60) {
                    gameSpeed -= 5;
                    clearInterval(gameLoop);
                    gameLoop = setInterval(update, gameSpeed);
                }
            } else {
                // Remove tail if no food eaten
                snake.pop();
            }
            
            // Check special food collision
            if (head.x === specialFood.x && head.y === specialFood.y) {
                // Apply power-up based on type
                const now = Date.now();
                const powerUpDuration = 10000; // 10 seconds
                
                switch(specialFood.type) {
                    case 0: // Speed boost
                        speedBoostActive = true;
                        speedBoostEndTime = now + powerUpDuration;
                        speedMultiplier = 2;
                        gameSpeed = baseSpeed / speedMultiplier;
                        clearInterval(gameLoop);
                        gameLoop = setInterval(update, gameSpeed);
                        speedElement.textContent = `${speedMultiplier}x`;
                        break;
                        
                    case 1: // Score multiplier
                        scoreMultiplierActive = true;
                        scoreMultiplierEndTime = now + powerUpDuration;
                        scoreMultiplier = 2;
                        break;
                        
                    case 2: // Slow time
                        slowTimeActive = true;
                        slowTimeEndTime = now + powerUpDuration;
                        speedMultiplier = 0.5;
                        gameSpeed = baseSpeed / speedMultiplier;
                        clearInterval(gameLoop);
                        gameLoop = setInterval(update, gameSpeed);
                        speedElement.textContent = `${speedMultiplier}x`;
                        break;
                }
                
                // Create new special food
                createSpecialFood();
                
                // Update score
                score += 20 * scoreMultiplier;
                scoreElement.textContent = score;
            }
            
            // Update power-up timers
            updatePowerUpTimers();
            
            // Draw updated game
            draw();
        }
        
        // Update power-up timer display
        function updatePowerUpTimers() {
            const now = Date.now();
            
            // Speed boost timer
            if (speedBoostActive && now < speedBoostEndTime) {
                const timeLeft = Math.ceil((speedBoostEndTime - now) / 1000);
                speedTimer.textContent = `${timeLeft}s`;
                speedTimer.style.color = "#00ff9d";
            } else if (speedBoostActive) {
                speedBoostActive = false;
                speedMultiplier = 1;
                gameSpeed = baseSpeed;
                clearInterval(gameLoop);
                gameLoop = setInterval(update, gameSpeed);
                speedElement.textContent = `${speedMultiplier}x`;
                speedTimer.textContent = "Inactive";
                speedTimer.style.color = "#cccccc";
            }
            
            // Score multiplier timer
            if (scoreMultiplierActive && now < scoreMultiplierEndTime) {
                const timeLeft = Math.ceil((scoreMultiplierEndTime - now) / 1000);
                multiplierTimer.textContent = `${timeLeft}s`;
                multiplierTimer.style.color = "#ffdd00";
            } else if (scoreMultiplierActive) {
                scoreMultiplierActive = false;
                scoreMultiplier = 1;
                multiplierTimer.textContent = "Inactive";
                multiplierTimer.style.color = "#cccccc";
            }
            
            // Slow time timer
            if (slowTimeActive && now < slowTimeEndTime) {
                const timeLeft = Math.ceil((slowTimeEndTime - now) / 1000);
                slowTimer.textContent = `${timeLeft}s`;
                slowTimer.style.color = "#00b7ff";
            } else if (slowTimeActive) {
                slowTimeActive = false;
                speedMultiplier = 1;
                gameSpeed = baseSpeed;
                clearInterval(gameLoop);
                gameLoop = setInterval(update, gameSpeed);
                speedElement.textContent = `${speedMultiplier}x`;
                slowTimer.textContent = "Inactive";
                slowTimer.style.color = "#cccccc";
            }
        }
        
        // Draw game
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#111a22';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw snake
            for (let i = 0; i < snake.length; i++) {
                const segment = snake[i];
                
                // Gradient color from head to tail
                const colorValue = Math.max(50, 255 - i * 10);
                const color = i === 0 ? '#4dffea' : `rgb(0, ${colorValue}, ${colorValue / 2})`;
                
                ctx.fillStyle = color;
                ctx.fillRect(
                    segment.x * gridSize, 
                    segment.y * gridSize, 
                    gridSize - 1, 
                    gridSize - 1
                );
                
                // Add rounded corners to head
                if (i === 0) {
                    ctx.fillStyle = '#00ff9d';
                    // Draw eyes based on direction
                    const eyeSize = gridSize / 5;
                    const eyeOffset = gridSize / 3;
                    
                    if (direction === 'right') {
                        ctx.fillRect(
                            segment.x * gridSize + gridSize - eyeOffset, 
                            segment.y * gridSize + eyeOffset, 
                            eyeSize, eyeSize
                        );
                        ctx.fillRect(
                            segment.x * gridSize + gridSize - eyeOffset, 
                            segment.y * gridSize + gridSize - eyeOffset - eyeSize, 
                            eyeSize, eyeSize
                        );
                    } else if (direction === 'left') {
                        ctx.fillRect(
                            segment.x * gridSize + eyeOffset - eyeSize, 
                            segment.y * gridSize + eyeOffset, 
                            eyeSize, eyeSize
                        );
                        ctx.fillRect(
                            segment.x * gridSize + eyeOffset - eyeSize, 
                            segment.y * gridSize + gridSize - eyeOffset - eyeSize, 
                            eyeSize, eyeSize
                        );
                    } else if (direction === 'up') {
                        ctx.fillRect(
                            segment.x * gridSize + eyeOffset, 
                            segment.y * gridSize + eyeOffset - eyeSize, 
                            eyeSize, eyeSize
                        );
                        ctx.fillRect(
                            segment.x * gridSize + gridSize - eyeOffset - eyeSize, 
                            segment.y * gridSize + eyeOffset - eyeSize, 
                            eyeSize, eyeSize
                        );
                    } else if (direction === 'down') {
                        ctx.fillRect(
                            segment.x * gridSize + eyeOffset, 
                            segment.y * gridSize + gridSize - eyeOffset, 
                            eyeSize, eyeSize
                        );
                        ctx.fillRect(
                            segment.x * gridSize + gridSize - eyeOffset - eyeSize, 
                            segment.y * gridSize + gridSize - eyeOffset, 
                            eyeSize, eyeSize
                        );
                    }
                }
            }
            
            // Draw regular food
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(
                food.x * gridSize + gridSize/2,
                food.y * gridSize + gridSize/2,
                gridSize/2 - 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // Draw special food with different colors based on type
            let specialFoodColor;
            switch(specialFood.type) {
                case 0: specialFoodColor = '#00ff9d'; break; // Speed - green
                case 1: specialFoodColor = '#ffdd00'; break; // Multiplier - yellow
                case 2: specialFoodColor = '#00b7ff'; break; // Slow - blue
            }
            
            ctx.fillStyle = specialFoodColor;
            ctx.beginPath();
            // Draw a star shape for special food
            const centerX = specialFood.x * gridSize + gridSize/2;
            const centerY = specialFood.y * gridSize + gridSize/2;
            const outerRadius = gridSize/2 - 2;
            const innerRadius = outerRadius/2;
            const spikes = 5;
            
            for (let i = 0; i < spikes * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = Math.PI / spikes * i;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.closePath();
            ctx.fill();
        }
        
        // Game over
        function gameOver() {
            gameRunning = false;
            clearInterval(gameLoop);
            
            // Update high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                highScoreElement.textContent = highScore;
            }
            
            // Show game over screen
            finalScoreElement.textContent = score;
            gameOverScreen.style.display = 'flex';
        }
        
        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            
            // Visual feedback for keys
            switch(e.key.toLowerCase()) {
                case 'w': keyW.classList.add('active'); break;
                case 'a': keyA.classList.add('active'); break;
                case 's': keyS.classList.add('active'); break;
                case 'd': keyD.classList.add('active'); break;
            }
            
            // Change direction (prevent 180-degree turns)
            switch(e.key.toLowerCase()) {
                case 'w':
                    if (direction !== 'down') nextDirection = 'up';
                    break;
                case 's':
                    if (direction !== 'up') nextDirection = 'down';
                    break;
                case 'a':
                    if (direction !== 'right') nextDirection = 'left';
                    break;
                case 'd':
                    if (direction !== 'left') nextDirection = 'right';
                    break;
            }
        });
        
        // Remove visual feedback when key is released
        document.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': keyW.classList.remove('active'); break;
                case 'a': keyA.classList.remove('active'); break;
                case 's': keyS.classList.remove('active'); break;
                case 'd': keyD.classList.remove('active'); break;
            }
        });
        
        // Restart game
        restartBtn.addEventListener('click', init);
        
        // Menu button (reloads page)
        menuBtn.addEventListener('click', () => {
            location.reload();
        });
        
        // Fullscreen toggle
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable fullscreen: ${err.message}`);
                });
                fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i>';
            } else {
                document.exitFullscreen();
                fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
            }
        });
        
        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        
        document.addEventListener('touchstart', (e) => {
            if (!gameRunning) return;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
        });
        
        document.addEventListener('touchend', (e) => {
            if (!gameRunning) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            
            // Determine swipe direction
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal swipe
                if (dx > 0 && direction !== 'left') {
                    nextDirection = 'right';
                } else if (dx < 0 && direction !== 'right') {
                    nextDirection = 'left';
                }
            } else {
                // Vertical swipe
                if (dy > 0 && direction !== 'up') {
                    nextDirection = 'down';
                } else if (dy < 0 && direction !== 'down') {
                    nextDirection = 'up';
                }
            }
        });
        
        // Start the game
        init();
    </script>
</body>
  </html>
